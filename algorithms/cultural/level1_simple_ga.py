import random
from typing import List, Tuple, Optional
import sys

# Standard boilerplate to allow importing from the parent directory
sys.path.append('..')
from algorithms.base_solver import BaseSolver


class SimpleGASolver(BaseSolver):
    """
    Level 1: Simple Genetic Algorithm (GA).

    CONCEPT:
    Instead of a single knight blindly searching (Level 0), we simulate a POPULATION
    of knights. We use 'Survival of the Fittest' to breed better solutions over time.

    MECHANISMS:
    1. Genotype: A list of integers (0-7) representing directions, not coordinates.
    2. Phenotype: The actual path on the board, generated by a 'Decoder'.
    3. Repair: If DNA says "Move off board", the Decoder fixes it locally.
    4. Evolution: Selection, Crossover (Breeding), and Mutation.
    """

    def __init__(self, n: int, level: int = 1, verbose: bool = False):
        super().__init__(n=n, level=level)

        # HYPERPARAMETERS (The "Settings" of Evolution)

        # How many knights exist in one generation.
        # Higher = More diversity but slower execution.
        self.population_size = 100

        # How many times we repeat the life/death cycle.
        self.generations = 100

        # The probability (30%) that a newborn child has a random gene change.
        # This prevents the population from getting stuck in one strategy.
        self.mutation_rate = 0.3

        # The length of the DNA list. Must be enough to cover the whole board.
        self.chromosome_length = n * n

        # ELITISM: The number of top performers copied unchanged to the next generation.
        # Guarantees the best solution never gets lost by accident.
        self.elitism_count = 2

        # How many knights fight for the right to reproduce in one bracket.
        self.tournament_size = 3

        # Statistics tracking
        self.best_fitness = 0
        self.best_path = []  # The actual path of the best solution found so far
        self.generation_best_fitness = []
        self.generation_avg_fitness = []
        self.mutation_count = 0
        self.crossover_count = 0
        self.verbose = verbose  # Flag to enable detailed terminal output

    def initialize_population(self) -> List[List[int]]:
        """
        Creates Generation 0.
        Since we have no parents yet, these are purely random.
        """
        population = []
        for _ in range(self.population_size):
            # Create a list of N*N random integers (0-7).
            # 0=Up-Right, 1=Right-Up, etc. (Indices of KNIGHT_MOVES)
            chromosome = [random.randint(0, 7) for _ in range(self.chromosome_length)]
            population.append(chromosome)
        return population

        # ---------------------------------------------------------
        # TEMPLATE METHOD: The Skeleton of the Algorithm
        # ---------------------------------------------------------
    def decode(self, chromosome: List[int], start_pos: Tuple[int, int]) -> List[Tuple[int, int]]:
            """
            Translates a chromosome (DNA directions) into a valid path.
            This is a 'Template Method': it defines the loop structure but delegates
            specific decisions to helper methods (_is_move_acceptable, _get_repair_move).
            """
            path = [start_pos]
            visited = {start_pos}  # Fast O(1) lookup for visited squares
            current_pos = start_pos

            for move_index in chromosome:
                if len(visited) >= self.n * self.n:
                    break

                next_pos = self.apply_move(current_pos, move_index)

                # HOOK 1: Decide if we should follow the DNA's suggestion
                if self._is_move_acceptable(next_pos, visited):
                    path.append(next_pos)
                    visited.add(next_pos)
                    current_pos = next_pos
                    continue

                    # HOOK 2: DNA failed, ask for a repair move
                best_move = self._get_repair_move(current_pos, visited)

                if not best_move:
                    break

                path.append(best_move)
                visited.add(best_move)
                current_pos = best_move

            return path

        # ---------------------------------------------------------
        # DEFAULT HOOKS (Level 1 Logic)
        # ---------------------------------------------------------
    def _is_move_acceptable(self, pos: Tuple[int, int], visited: set) -> bool:
            """Level 1 Logic: Accept any valid, unvisited move."""
            return self.is_valid_position(pos[0], pos[1]) and pos not in visited

    def _get_repair_move(self, current_pos: Tuple[int, int], visited: set) -> Optional[Tuple[int, int]]:
            """
            Level 1 Logic: Greedy Repair.
            We maximize future moves. This is the OPPOSITE of Warnsdorff's rule.
            It tends to get stuck in the middle, performing worse than Level 2/3.
            """
            valid_moves = self.get_valid_moves_from(current_pos[0], current_pos[1], visited)

            if not valid_moves:
                return None

            candidates = valid_moves[:min(3, len(valid_moves))]

            # Greedy: Pick the one with the MOST options (max).
            return max(candidates,
                       key=lambda m: len(self.get_valid_moves_from(m[0], m[1], visited | {m})),
                       default=candidates[0])

    def fitness(self, chromosome: List[int], start_pos: Tuple[int, int]) -> float:
        """
        The Scoreboard.
        Determines how 'good' a specific knight is.
        Higher score = Higher chance of reproducing.
        """
        # 1. Convert DNA to actual Path
        path = self.decode(chromosome, start_pos)
        if not path:
            return 0.0

        unique_count = len(path)  # Length of path (decode ensures uniqueness)
        legal_transitions = 0

        # 2. Verify Geometry (Sanity Check)
        # We loop through the path to confirm moves are L-shaped.
        for i in range(len(path) - 1):
            x1, y1 = path[i]
            x2, y2 = path[i + 1]
            dx, dy = abs(x2 - x1), abs(y2 - y1)

            # Check L-shape geometry (2x1 or 1x2)
            if (dx == 2 and dy == 1) or (dx == 1 and dy == 2):
                legal_transitions += 1

        # 3. Calculate Score
        # Weight 1: 10 points for every square visited (Primary Goal)
        # Weight 2: 5 points for every legal move (Secondary Goal)
        fitness_score = unique_count * 10 + legal_transitions * 5
        return float(fitness_score)

    def select_parents(self, population: List[List[int]], fitness_scores: List[float]) -> List[List[int]]:
        """
        Natural Selection.
        Decides who gets to breed the next generation.
        """
        # Sort everyone by score (Highest first)
        sorted_indices = sorted(range(len(fitness_scores)), key=lambda i: fitness_scores[i], reverse=True)

        # 1. ELITISM: The top 'elitism_count' (2) are automatically selected.
        # They survive unchanged to ensure we never lose our best solution.
        elite = [population[i] for i in sorted_indices[:self.elitism_count]]
        parents = elite.copy()

        # 2. TOURNAMENT: Fill the rest of the parent slots.
        # We need enough parents to create the next generation (pop_size).
        # We select half the population size as parents, who will each breed twice (roughly).
        while len(parents) < self.population_size // 2:
            winner = self.tournament_selection(population, fitness_scores)
            parents.append(winner)
        return parents

    def tournament_selection(self, population: List[List[int]], fitness_scores: List[float]) -> List[int]:
        """
        Helper for Selection.
        Picks 3 random knights, and the one with the best score wins.
        """
        # Randomly select 3 indices
        tournament_indices = random.sample(range(len(population)), min(self.tournament_size, len(population)))
        # Find the max fitness among those 3
        best_idx = max(tournament_indices, key=lambda i: fitness_scores[i])
        # Return a COPY of the winner's DNA
        return population[best_idx].copy()

    def crossover(self, p1: List[int], p2: List[int]) -> Tuple[List[int], List[int]]:
        """
        Breeding (Two-Point Crossover).
        Combines the DNA of two parents to create two children.
        """
        # Safety check: need enough genes to cut
        if len(p1) < 2 or len(p2) < 2:
            return p1.copy(), p2.copy()

        # Select two random cut points
        point1 = random.randint(1, len(p1) - 2)
        point2 = random.randint(point1 + 1, len(p1))

        # Splice the lists:
        # Child 1: Mom's Start + Dad's Middle + Mom's End
        child1 = p1[:point1] + p2[point1:point2] + p1[point2:]
        # Child 2: Dad's Start + Mom's Middle + Dad's End
        child2 = p2[:point1] + p1[point1:point2] + p2[point2:]

        # Repair lengths (Splicing can sometimes mess up list length)
        child1 = self._repair_chromosome(child1)
        child2 = self._repair_chromosome(child2)

        self.crossover_count += 1
        return child1, child2

    def _repair_chromosome(self, chromosome: List[int]) -> List[int]:
        """
        Housekeeping function.
        Ensures DNA is valid (integers 0-7) and correct length (N*N).
        """
        repaired = []

        # 1. Validate Values
        for gene in chromosome:
            if 0 <= gene <= 7:
                repaired.append(gene)
            else:
                repaired.append(random.randint(0, 7))

        # 2. Validate Length
        # If too short, fill with random genes
        if len(repaired) < self.chromosome_length:
            repaired.extend([random.randint(0, 7) for _ in range(self.chromosome_length - len(repaired))])
        # If too long, cut off the end
        elif len(repaired) > self.chromosome_length:
            repaired = repaired[:self.chromosome_length]

        return repaired

    def mutate(self, chromosome: List[int]) -> List[int]:
        """
        Mutation.
        Introduces random changes to maintain diversity.
        """
        # 70% chance to return original (No mutation)
        if random.random() > self.mutation_rate:
            return chromosome

        mutated = chromosome.copy()
        # Decide how many genes to flip (1 to 3)
        num_mutations = random.randint(1, 3)

        for _ in range(num_mutations):
            # Pick a random gene index
            pos = random.randint(0, len(mutated) - 1)

            if pos > 0:
                # Level 1 Smart Logic:
                # Avoid setting a move equal to the previous move.
                # e.g., Move 0 then Move 0 = Straight line (bad for Knight).
                prev_move = mutated[pos - 1]
                candidate_moves = list(range(8))  # [0..7]

                if prev_move in candidate_moves:
                    candidate_moves.remove(prev_move)  # Remove previous direction

                # Pick from remaining
                mutated[pos] = random.choice(candidate_moves) if candidate_moves else random.randint(0, 7)
            else:
                # First gene has no previous move, pick purely random
                mutated[pos] = random.randint(0, 7)

        self.mutation_count += 1
        return mutated

    def evolve(self, start_pos: Tuple[int, int]) -> Tuple[bool, List[Tuple[int, int]]]:
        """
        The Main Engine.
        Orchestrates the entire evolutionary process.
        """
        # 1. Initialization
        population = self.initialize_population()
        self.generation_best_fitness = []
        self.generation_avg_fitness = []
        self.mutation_count = 0
        self.crossover_count = 0

        # Verbose Output (Initial State)
        if self.verbose:
            print(f"\n{'=' * 70}")
            print(f"LEVEL 1: SIMPLE GENETIC ALGORITHM")
            # ... (Print settings) ...
            print(f"{'=' * 70}\n")

        # 2. Main Evolution Loop
        for generation in range(self.generations):
            # A. Evaluate entire population
            fitness_scores = [self.fitness(chrom, start_pos) for chrom in population]

            # B. Statistics Tracking
            best_idx = fitness_scores.index(max(fitness_scores))
            best_fitness = fitness_scores[best_idx]
            avg_fitness = sum(fitness_scores) / len(fitness_scores)

            self.generation_best_fitness.append(best_fitness)
            self.generation_avg_fitness.append(avg_fitness)

            # C. Update Global Best
            # If current generation's best is better than all-time best, save it.
            if best_fitness > self.best_fitness:
                self.best_fitness = best_fitness
                self.best_path = self.decode(population[best_idx], start_pos)

                if self.verbose:
                    print(f" NEW BEST! Gen {generation}: Fitness={best_fitness:.1f}")

            # Verbose Output (Progress Report every 10 gens)
            if self.verbose and generation % 10 == 0:
                # ... (Print current stats) ...
                pass

            # D. Selection
            parents = self.select_parents(population, fitness_scores)

            # E. Breeding Next Generation
            new_population = []

            # 1. Elitism: Copy top 2 parents directly
            sorted_indices = sorted(range(len(fitness_scores)),
                                    key=lambda i: fitness_scores[i], reverse=True)
            for i in sorted_indices[:self.elitism_count]:
                new_population.append(population[i].copy())

            # 2. Fill rest via Crossover & Mutation
            while len(new_population) < self.population_size:
                # Pick 2 parents
                p1 = random.choice(parents)
                p2 = random.choice(parents)

                # Breed
                child1, child2 = self.crossover(p1, p2)

                # Mutate
                child1 = self.mutate(child1)
                child2 = self.mutate(child2)

                # Add to new population
                new_population.append(child1)
                if len(new_population) < self.population_size:
                    new_population.append(child2)

            # Replace old population
            population = new_population

        # 3. Final Result Verification
        target_squares = self.n * self.n
        unique_visited = len(set(self.best_path))
        success = unique_visited == target_squares

        # Verbose Output (Summary)
        if self.verbose:
            print(f"\n{'=' * 70}")
            print(f"EVOLUTION COMPLETE")
            # ... (Print final results) ...
            print(f"{'=' * 70}\n")

        return success, self.best_path

    def solve(self, start_x: int, start_y: int) -> Tuple[bool, List[Tuple[int, int]]]:
        """
        Public Interface.
        Resets stats and starts the evolution.
        """
        self.start_pos = (start_x, start_y)
        self.best_fitness = 0
        self.best_path = []
        success, path = self.evolve(self.start_pos)
        return success, path
